%
{
#include <iostream>
#include <cstdlib>

#include <cmath>
#include <vector>
#include <string>
#include <limits>
#include <sstream>
#include "1505069_SymbolTable.h"
	//#define YYSTYPE SymbolInfo*

	//IDVALUE -> AssemblyID
	//setType -> isArray
	//asm_code -> Code
	//decTyoe -> Return type
	using namespace std;

	int yyparse(void);
	int yylex(void);
	extern FILE *yyin;
	FILE *fp;
	FILE *error = fopen("error.txt", "w");
	FILE *parsertext = fopen("parsertext.txt", "w");
	int line_count = 1;
	int error_count = 0;

	SymbolTable *table = new SymbolTable(100, parsertext);
	vector<SymbolInfo *> para_list;
	vector<SymbolInfo *> dec_list;
	vector<SymbolInfo *> arg_list;
	vector<string> var_dec;
	vector<string> func_var_dec;
	vector<pair<string, string>> arr_dec;
	string curfunction;

	void yyerror(const string s)
	{
		error_count++;
		fprintf(error, "Line no %d : %s\n\n", line_count, s);
	}

	int labelCount = 0;
	int tempCount = 0;
	string IntToint a)
	{
		ostringstream temp;
		temp << a;
		return temp.str();
	}

	string newLabel()
	{
		string lb = new char[4];
		strcpy(lb, "L");
		char b[3];
		sprintf(b, "%d", labelCount);
		labelCount++;
		strcat(lb, b);
		return lb;
	}

	string generateNewTempVariable()
	{
		string t = new char[4];
		strcpy(t, "t");
		char b[3];
		sprintf(b, "%d", tempCount);
		tempCount++;
		strcat(t, b);
		return t;
	}

	void optimization(FILE * asmcode);

	%
}

% error - verbose % token IF ELSE FOR WHILE DO BREAK % token INT FLOAT CHAR DOUBLE VOID % token RETURN SWITCH CASE DEFAULT CONTINUE % token CONST_INT CONST_FLOAT CONST_CHAR % token ADDOP MULOP INCOP RELOP ASSIGNOP LOGICOP BITOP NOT DECOP % token LPAREN RPAREN LCURL RCURL LTHIRD RTHIRD COMMA SEMICOLON % token STRING ID PRINTLN

			  % left RELOP LOGICOP BITOP % left ADDOP % left MULOP

			  % nonassoc LOWER_THAN_ELSE % nonassoc ELSE

			  % union {
	SymbolInfo *symbolinfo;
	vector<string> *s;
} % type<s> start

	% %

	start : program
{
	if (error_count == 0)
	{
		string code = "";
		code += ".MODEL SMALL\n\.STACK 100H\n\.DATA \n";

		for (int i = 0; i < var_dec.size(); i++)
		{
			code += var_dec[i] + " dw ?\n";
		}
		for (int i = 0; i < arr_dec.size(); i++)
		{
			code += arr_dec[i].first + " dw " + arr_dec[i].second + " dup(?)\n";
		}

		$1->setCode(code + ".CODE\n" + $1->getCode());

		$1->setCode($1->getCode() + "OUTDEC PROC  \n\ 
PUSH AX \n\ 
PUSH BX \n\ 
PUSH CX \n\ 
PUSH DX  \n\ 
CMP AX,0 \n\ 
JGE BEGIN \n\ 
PUSH AX \n\ 
MOV DL,'-' \n\ 
MOV AH,2 \n\ 
INT 21H \n\ 
POP AX \n\ 
NEG AX \n\ 
\n\ 
BEGIN: \n\ 
XOR CX,CX \n\ 
MOV BX,10 \n\ 
\n\ 
REPEAT: \n\ 
XOR DX,DX \n\ 
DIV BX \n\ 
PUSH DX \n\ 
INC CX \n\ 
OR AX,AX \n\ 
JNE REPEAT \n\ 
MOV AH,2 \n\ 
\n\ 
PRINT_LOOP: \n\ 
POP DX \n\ 
ADD DL,30H \n\ 
INT 21H \n\ 
LOOP PRINT_LOOP \n\ 
\n\    
MOV AH,2\n\
MOV DL,10\n\
INT 21H\n\
\n\
MOV DL,13\n\
INT 21H\n\
\n\
POP DX \n\ 
POP CX \n\ 
POP BX \n\ 
POP AX \n\ 
ret \n\ 
OUTDEC ENDP \n\
END MAIN\n");
		FILE *asmcode = fopen("code.asm", "w");

		fprintf(asmcode, "%s", $1->getCode().c_str());
		fclose(asmcode);
		asmcode = fopen("code.asm", "r");
		optimization(asmcode);
	}
}

;

program : program unit
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : program->program unit\n\n", line_count);
	fprintf(parsertext, "%s %s\n\n", $1->getName().c_str(), $2->getName().c_str());
	$$->setName($1->getName() + $2->getName());
	$$->setCode($1->getCode() + $2->getCode());
}

| unit
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : program->unit\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName());
	$$->setCode($1->getCode());
};

unit : var_declaration
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : unit->var_declaration\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName() + "\n");
	func_var_dec.clear();
	$$->setCode($1->getCode());
}
| func_declaration
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : unit->func_declaration\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName() + "\n");
	$$->setCode($1->getCode());
}
| func_definition
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : unit->func_definition\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName() + "\n");
	$$->setCode($1->getCode());
};

func_declaration : type_specifier ID LPAREN parameter_list RPAREN SEMICOLON
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : func_declaration->type_specifier ID LPAREN parameter_list RPAREN SEMICOLON\n\n", line_count);
	fprintf(parsertext, "%s %s(%s);\n\n", $1->getName().c_str(), $2->getName().c_str(), $4->getName().c_str());
	SymbolInfo *s = table->lookup($2->getName());
	if (s == 0)
	{
		table->Insert($2->getName(), "ID", "Function");
		s = table->lookup($2->getName());
		s->set_isFunction();
		for (int i = 0; i < para_list.size(); i++)
		{
			s->get_isFunction()->add_number_of_parameter(para_list[i]->getName(), para_list[i]->getReturnType());
			//cout<<para_list[i]->getReturnType()<<endl;
		}
		para_list.clear();
		s->get_isFunction()->set_return_type($1->getName());
	}
	else
	{
		int num = s->get_isFunction()->get_number_of_parameter();
		//	cout<<line_count<<" "<<para_list.size()<<endl;
		//	$$->setReturnType(s->get_isFunction()->get_return_type());
		if (num != para_list.size())
		{
			error_count++;
			fprintf(error, "Error at Line No.%d:  Invalid number of parameters \n\n", line_count);
		}
		else
		{

			vector<string> para_type = s->get_isFunction()->get_paratype();
			for (int i = 0; i < para_list.size(); i++)
			{
				if (para_list[i]->getReturnType() != para_type[i])
				{
					error_count++;
					fprintf(error, "Error at Line No.%d: Type Mismatch \n\n", line_count);
					break;
				}
			}
			if (s->get_isFunction()->get_return_type() != $1->getName())
			{
				error_count++;
				fprintf(error, "Error at Line No.%d: Return Type Mismatch \n\n", line_count);
			}
			para_list.clear();
		}
	}

	$$->setName($1->getName() + " " + $2->getName() + "(" + $4->getName() + ");");
}
| type_specifier ID LPAREN RPAREN SEMICOLON
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : func_declaration->type_specifier ID LPAREN RPAREN SEMICOLON\n\n", line_count);
	fprintf(parsertext, "%s %s();\n\n", $1->getName().c_str(), $2->getName().c_str());
	SymbolInfo *s = table->lookup($2->getName());
	if (s == 0)
	{
		table->Insert($2->getName(), "ID", "Function");
		s = table->lookup($2->getName());
		s->set_isFunction();
		s->get_isFunction()->set_return_type($1->getName());
	}
	else
	{
		if (s->get_isFunction()->get_number_of_parameter() != 0)
		{
			error_count++;
			fprintf(error, "Error at Line No.%d:  Invalid number of parameters \n\n", line_count);
		}
		if (s->get_isFunction()->get_return_type() != $1->getName())
		{
			error_count++;
			fprintf(error, "Error at Line No.%d: Return Type Mismatch \n\n", line_count);
		}
	}
	$$->setName($1->getName() + " " + $2->getName() + "();");
};

func_definition : type_specifier ID LPAREN parameter_list RPAREN
{
	$$ = new SymbolInfo();

	SymbolInfo *s = table->lookup($2->getName());
	if (s != 0)
	{
		if (s->get_isFunction()->get_isdefined() == 0)
		{
			int num = s->get_isFunction()->get_number_of_parameter();
			//	cout<<line_count<<" "<<para_list.size()<<endl;
			//	$$->setReturnType(s->get_isFunction()->get_return_type());
			if (num != para_list.size())
			{
				error_count++;
				fprintf(error, "Error at Line No.%d:  Invalid number of parameters \n\n", line_count);
			}
			else
			{

				vector<string> para_type = s->get_isFunction()->get_paratype();
				for (int i = 0; i < para_list.size(); i++)
				{
					if (para_list[i]->getReturnType() != para_type[i])
					{
						error_count++;
						fprintf(error, "Error at Line No.%d: Type Mismatch \n\n", line_count);
						break;
					}
				}
				if (s->get_isFunction()->get_return_type() != $1->getName())
				{
					error_count++;
					fprintf(error, "Error at Line No.%d: Return Type Mismatch1 \n\n", line_count);
				}
				//	para_list.clear();
			}
			s->get_isFunction()->getclear();
			for (int i = 0; i < para_list.size(); i++)
			{
				s->get_isFunction()->add_number_of_parameter(para_list[i]->getName() + IntTotable->getNextId()), para_list[i]->getReturnType());
				//	cout<<para_list[i]->getReturnType()<<para_list[i]->getName()<<endl;
			}
			s->get_isFunction()->set_isdefined();
		}
		else
		{
			error_count++;
			fprintf(error, "Error at Line No.%d:  Multiple defination of function %s\n\n", line_count, $2->getName().c_str());
		}
	}
	else
	{ //cout<<para_list.size()<<" "<<line_count<<endl;
		table->Insert($2->getName(), "ID", "Function");
		s = table->lookup($2->getName());
		s->set_isFunction();
		//cout<<s->get_isFunction()->get_number_of_parameter()<<endl;
		s->get_isFunction()->set_isdefined();
		for (int i = 0; i < para_list.size(); i++)
		{
			s->get_isFunction()->add_number_of_parameter(para_list[i]->getName() + IntTotable->getNextId()), para_list[i]->getReturnType());
			//	cout<<para_list[i]->getReturnType()<<para_list[i]->getName()<<endl;
		}
		//	para_list.clear();
		s->get_isFunction()->set_return_type($1->getName());
		//cout<<table->getNextId()<<endl;
		//cout<<line_count<<" "<<s->get_isFunction()->get_return_type()<<endl;
	}
	curfunction = $2->getName();
	var_dec.push_back(curfunction + "_return");
}
compound_statement
{
	ewfprintf(parsertext, "Line at %d : func_definition->type_specifier ID LPAREN parameter_list RPAREN compound_statement \n\n", line_count);
	fprintf(parsertext, "%s %s(%s) %s \n\n", $1->getName().c_str(), $2->getName().c_str(), $4->getName().c_str(), $7->getName().c_str());
	$$->setCode($2->getName() + " PROC\n");

	if ($2->getName() == "main")
	{
		$$->setCode($$->getCode() + "    MOV AX,@DATA\nMOV DS,AX \n" + $7->getCode() + "LReturn" + curfunction + ":\nMOV AH,4CH\nINT 21H\n");
	}
	else
	{
		SymbolInfo *s = table->lookup($2->getName());

		for (int i = 0; i < func_var_dec.size(); i++)
		{
			s->get_isFunction()->add_var(func_var_dec[i]);
		}
		func_var_dec.clear();

		string code = $$->getCode() +
					  "PUSH AX\nPUSH BX \nPUSH CX \nPUSH DX\n";

		vector<string> para_list = s->get_isFunction()->get_paralist();
		vector<string> var_list = s->get_isFunction()->get_var();
		for (int i = 0; i < para_list.size(); i++)
		{
			code += "PUSH " + para_list[i] + "\n";
		}
		for (int i = 0; i < var_list.size(); i++)
		{
			code += "PUSH " + var_list[i] + "\n";
		}
		code += $7->getCode() +
				"LReturn" + curfunction + ":\n";
		for (int i = var_list.size() - 1; i >= 0; i--)
		{
			code += "POP " + var_list[i] + "\n";
		}
		for (int i = para_list.size() - 1; i >= 0; i--)
		{
			code += "POP " + para_list[i] + "\n";
		}

		code += "POP DX\nPOP CX\nPOP BX\nPOP AX\nret\n";

		$$->setCode(code + $2->getName() + " ENDP\n");
	}

	$$->setName($1->getName() + " " + $2->getName() + "(" + $4->getName() + ")" + $7->getName());
}
| type_specifier ID LPAREN RPAREN
{
	$$ = new SymbolInfo();
	SymbolInfo *s = table->lookup($2->getName());
	if (s == 0)
	{
		table->Insert($2->getName(), "ID", "Function");
		s = table->lookup($2->getName());
		s->set_isFunction();
		s->get_isFunction()->set_isdefined();
		s->get_isFunction()->set_return_type($1->getName());
		//	cout<<line_count<<" "<<s->get_isFunction()->get_return_type()<<endl;
	}
	else if (s->get_isFunction()->get_isdefined() == 0)
	{
		if (s->get_isFunction()->get_number_of_parameter() != 0)
		{
			error_count++;
			fprintf(error, "Error at Line No.%d:  Invalid number of parameters \n\n", line_count);
		}
		if (s->get_isFunction()->get_return_type() != $1->getName())
		{
			error_count++;
			fprintf(error, "Error at Line No.%d: Return Type Mismatch \n\n", line_count);
		}

		s->get_isFunction()->set_isdefined();
	}
	else
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Multiple defination of function %s\n\n", line_count, $2->getName().c_str());
	}
	//cout<<table->getNextId()<<endl;
	curfunction = $2->getName();
	var_dec.push_back(curfunction + "_return");
	$1->setName($1->getName() + " " + $2->getName() + "()");
}
compound_statement
{
	fprintf(parsertext, "Line at %d : func_definition->type_specifier ID LPAREN RPAREN compound_statement\n\n", line_count);
	fprintf(parsertext, "%s %s\n\n", $1->getName().c_str(), $6->getName().c_str());
	$$->setCode($2->getName() + " PROC\n");

	if ($2->getName() == "main")
	{
		$$->setCode($$->getCode() + "    MOV AX,@DATA\nMOV DS,AX \n" + $6->getCode() + "LReturn" + curfunction + ":\nMOV AH,4CH\nINT 21H\n");
	}
	else
	{
		SymbolInfo *s = table->lookup($2->getName());

		for (int i = 0; i < func_var_dec.size(); i++)
		{
			s->get_isFunction()->add_var(func_var_dec[i]);
		}
		func_var_dec.clear();

		string code = $$->getCode() +
					  "PUSH AX\nPUSH BX \nPUSH CX \nPUSH DX\n";

		vector<string> para_list = s->get_isFunction()->get_paralist();
		vector<string> var_list = s->get_isFunction()->get_var();
		for (int i = 0; i < para_list.size(); i++)
		{
			code += "PUSH " + para_list[i] + "\n";
		}
		for (int i = 0; i < var_list.size(); i++)
		{
			code += "PUSH " + var_list[i] + "\n";
		}
		code += $6->getCode() +
				"LReturn" + curfunction + ":\n";
		for (int i = var_list.size() - 1; i >= 0; i--)
		{
			code += "POP " + var_list[i] + "\n";
		}
		for (int i = para_list.size() - 1; i >= 0; i--)
		{
			code += "POP " + para_list[i] + "\n";
		}

		code += "POP DX\nPOP CX\nPOP BX\nPOP AX\nret\n";

		$$->setCode(code + $2->getName() + " ENDP\n");
	}

	$$->setName($1->getName() + $6->getName());
};

parameter_list : parameter_list COMMA type_specifier ID
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : parameter_list->parameter_list COMMA type_specifier ID\n\n", line_count);
	fprintf(parsertext, "%s,%s %s\n\n", $1->getName().c_str(), $3->getName().c_str(), $4->getName().c_str());
	para_list.push_back(new SymbolInfo($4->getName(), "ID", $3->getName()));
	$$->setName($1->getName() + "," + $3->getName() + " " + $4->getName());
}
| parameter_list COMMA type_specifier
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : parameter_list->parameter_list COMMA type_specifier\n\n", line_count);
	fprintf(parsertext, "%s,%s\n\n", $1->getName().c_str(), $3->getName().c_str());
	para_list.push_back(new SymbolInfo("", "ID", $3->getName()));
	$$->setName($1->getName() + "," + $3->getName());
}
| type_specifier ID
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : parameter_list->type_specifier ID\n\n", line_count);
	fprintf(parsertext, "%s %s\n\n", $1->getName().c_str(), $2->getName().c_str());
	para_list.push_back(new SymbolInfo($2->getName(), "ID", $1->getName()));
	$$->setName($1->getName() + " " + $2->getName());
}
| type_specifier
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : parameter_list->type_specifier\n\n", line_count);
	fprintf(parsertext, "%s \n\n", $1->getName().c_str());
	para_list.push_back(new SymbolInfo("", "ID", $1->getName()));
	$$->setName($1->getName() + " ");
};

compound_statement : LCURL
{
	table->Enter_Scope();
	//	cout<<line_count<<" "<<para_list.size()<<endl;
	for (int i = 0; i < para_list.size(); i++)
	{
		table->Insert(para_list[i]->getName(), "ID", para_list[i]->getReturnType());
		//table->printcurrent();
		var_dec.push_back(para_list[i]->getName() + IntTotable->getCurrentId()));
	}
	para_list.clear();
}
statements RCURL
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : compound_statement->LCURL statements RCURL\n\n", line_count);
	fprintf(parsertext, "{%s}\n\n", $3->getName().c_str());
	$$->setName("{\n" + $3->getName() + "\n}");
	$$->setCode($3->getCode());
	table->printall();
	table->Exit_Scope();
}
| LCURL RCURL
{
	table->Enter_Scope();
	for (int i = 0; i < para_list.size(); i++)
	{
		table->Insert(para_list[i]->getName(), "ID", para_list[i]->getReturnType());
		//table->printcurrent();
		var_dec.push_back(para_list[i]->getName() + IntTotable->getCurrentId()));
	}
	para_list.clear();
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : compound_statement->LCURL RCURL\n\n", line_count);
	fprintf(parsertext, "{}\n\n");
	$$->setName("{}");
	table->printall();
	table->Exit_Scope();
};

var_declaration : type_specifier declaration_list SEMICOLON
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : var_declaration->type_specifier declaration_list SEMICOLON\n\n", line_count);
	fprintf(parsertext, "%s %s;\n\n", $1->getName().c_str(), $2->getName().c_str());
	if ($1->getName() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d: Type specifier can not be void \n\n", line_count);
	}
	else
	{
		//	func_var_dec.clear();
		for (int i = 0; i < dec_list.size(); i++)
		{

			if (table->lookupcurrent(dec_list[i]->getName()))
			{
				error_count++;
				fprintf(error, "Error at Line No.%d:  Multiple Declaration of %s \n\n", line_count, dec_list[i]->getName().c_str());
				continue;
			}
			if (dec_list[i]->get_type().size() > 2)
			{
				arr_dec.push_back(make_pair(dec_list[i]->getName() + IntTotable->getCurrentId()),

											dec_list[i]->get_type().substr(2, dec_list[i]->get_type().size() - 1)));

				dec_list[i]->set_type(dec_list[i]->get_type().substr(0, dec_list[i]->get_type().size() - 1));

				table->Insert(dec_list[i]->getName(), dec_list[i]->get_type(), $1->getName() + "array");
			}
			else
			{
				func_var_dec.push_back(dec_list[i]->getName() + IntTotable->getCurrentId()));
				table->Insert(dec_list[i]->getName(), dec_list[i]->get_type(), $1->getName());
				var_dec.push_back(dec_list[i]->getName() + IntTotable->getCurrentId()));
			}
		}
	}

	dec_list.clear();
	$$->setName($1->getName() + " " + $2->getName() + ";");
};

type_specifier : INT
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : type_specifier	: INT\n\n", line_count);
	fprintf(parsertext, "int \n\n");
	$$->setName("int ");
}
| FLOAT
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : type_specifier	: FLOAT\n\n", line_count);
	fprintf(parsertext, "float \n\n");
	$$->setName("float ");
}
| VOID
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : type_specifier	: VOID\n\n", line_count);
	fprintf(parsertext, "void \n\n");
	$$->setName("void ");
};

declaration_list : declaration_list COMMA ID
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : declaration_list->declaration_list COMMA ID\n\n", line_count);
	fprintf(parsertext, "%s,%s\n\n", $1->getName().c_str(), $3->getName().c_str());
	dec_list.push_back(new SymbolInfo($3->getName(), "ID"));
	$$->setName($1->getName() + "," + $3->getName());
}
| declaration_list COMMA ID LTHIRD CONST_INT RTHIRD
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : declaration_list->declaration_list COMMA ID LTHIRD CONST_INT RTHIRD\n\n", line_count);
	fprintf(parsertext, "%s,%s[%s]\n\n", $1->getName().c_str(), $3->getName().c_str(), $5->getName().c_str());
	dec_list.push_back(new SymbolInfo($3->getName(), "ID" + $5->getName()));
	$$->setName($1->getName() + "," + $3->getName() + "[" + $5->getName() + "]");
}
| ID
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : declaration_list->ID\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	dec_list.push_back(new SymbolInfo($1->getName(), "ID"));
	$$->setName($1->getName());
}
| ID LTHIRD CONST_INT RTHIRD
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : declaration_list->ID LTHIRD CONST_INT RTHIRD\n\n", line_count);
	fprintf(parsertext, "%s[%s]\n\n", $1->getName().c_str(), $3->getName().c_str());
	dec_list.push_back(new SymbolInfo($1->getName(), "ID" + $3->getName()));
	$$->setName($1->getName() + "[" + $3->getName() + "]");
};

statements : statement
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : statements->statement\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName());
	$$->setCode($1->getCode());
}
| statements statement
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : statements->statements statement\n\n", line_count);
	fprintf(parsertext, "%s %s\n\n", $1->getName().c_str(), $2->getName().c_str());
	$$->setName($1->getName() + "\n" + $2->getName());
	$$->setCode($1->getCode() + $2->getCode());
};

statement : var_declaration
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : statement -> var_declaration\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName());
}
| expression_statement
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : statement -> expression_statement\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName());
	$$->setCode($1->getCode());
}
| compound_statement
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : statement->compound_statement\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName());
	$$->setCode($1->getCode());
}
| FOR LPAREN expression_statement expression_statement expression RPAREN statement
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : statement ->FOR LPAREN expression_statement expression_statement expression RPAREN statement\n\n", line_count);
	fprintf(parsertext, "for(%s %s %s)\n%s \n\n", $3->getName().c_str(), $4->getName().c_str(), $5->getName().c_str(), $7->getName().c_str());
	if ($3->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		//$$->setReturnType("int ");
	}
	else
	{
		//cout<<line_count<<" "<<$7->getCode()<<endl;
		string code = $3->getCode();
		string label1 = newLabel();
		string label2 = newLabel();
		code += label1 + ":\n";
		code += $4->getCode();
		code += "MOV AX," + $4->getAssemblyID() + "\n";
		code += "CMP AX,0\n";
		code += "JE " + label2 + "\n";
		code += $7->getCode();
		code += $5->getCode();
		code += "JMP " + label1 + "\n";
		code += label2 + ":\n";
		$$->setCode(code);
	}

	$$->setName("for(" + $3->getName() + $4->getName() + $5->getName() + ")\n" + $5->getName());
}
| IF LPAREN expression RPAREN statement % prec LOWER_THAN_ELSE
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : statement->IF LPAREN expression RPAREN statement\n\n", line_count);
	fprintf(parsertext, "if(%s)\n%s\n\n", $3->getName().c_str(), $5->getName().c_str());
	if ($3->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		//$$->setReturnType("int ");
	}
	else
	{
		string code = $3->getCode();
		string label1 = newLabel();
		code += "MOV AX," + $3->getAssemblyID() + "\n";
		code += "CMP AX,0\n";
		code += "JE " + label1 + "\n";
		code += $5->getCode();
		code += label1 + ":\n";
		$$->setCode(code);
	}

	$$->setName("if(" + $3->getName() + ")\n" + $5->getName());
}
| IF LPAREN expression RPAREN statement ELSE statement
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : statement->IF LPAREN expression RPAREN statement ELSE statement\n\n", line_count);
	fprintf(parsertext, "if(%s)\n%s\n else \n %s\n\n", $3->getName().c_str(), $5->getName().c_str(), $7->getName().c_str());
	if ($3->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		//$$->setReturnType("int ");
	}
	else
	{
		string code = $3->getCode();
		string label1 = newLabel();
		string label2 = newLabel();
		code += "MOV AX," + $3->getAssemblyID() + "\n";
		code += "CMP AX,0\n";
		code += "JE " + label1 + "\n";
		code += $5->getCode();
		code += "JMP " + label2 + "\n";
		code += label1 + ":\n";
		code += $7->getCode();
		code += label2 + ":\n";
		$$->setCode(code);
	}

	$$->setName("if(" + $3->getName() + ")\n" + $5->getName() + " else \n" + $7->getName());
}

| WHILE LPAREN expression RPAREN statement
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : statement->WHILE LPAREN expression RPAREN statement\n\n", line_count);
	fprintf(parsertext, "while(%s)\n%s\n\n", $3->getName().c_str(), $5->getName().c_str());
	if ($3->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		//	$$->setReturnType("int ");
	}
	else
	{
		string code = "";
		string label1 = newLabel();
		string label2 = newLabel();
		code += label1 + ":\n";
		code += $3->getCode();
		code += "MOV AX," + $3->getAssemblyID() + "\n";
		code += "CMP AX,0\n";
		code += "JE " + label2 + "\n";
		code += $5->getCode();
		code += "JMP " + label1 + "\n";
		code += label2 + ":\n";
		$$->setCode(code);
	}
	$$->setName("while(" + $3->getName() + ")\n" + $5->getName());
}
| PRINTLN LPAREN ID RPAREN SEMICOLON
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : statement->PRINTLN LPAREN ID RPAREN SEMICOLON\n\n", line_count);
	fprintf(parsertext, "\n (%s);\n\n", $3->getName().c_str());
	string code = "";
	if (table->lookupscopeid($3->getName()) == -1)
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Undeclared Variable: %s \n\n", line_count, $3->getName().c_str());
	}
	else
	{

		code += "MOV AX," + $3->getName() + IntTotable->lookupscopeid($3->getName()));
		code += "\nCALL OUTDEC\n";
	}
	$$->setName("println(" + $3->getName() + ");");

	$$->setCode(code);
}
| RETURN expression SEMICOLON
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : statement->RETURN expression SEMICOLON\n\n", line_count);
	fprintf(parsertext, "return %s;\n\n", $2->getName().c_str());
	if ($2->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		$$->setReturnType("int ");
	}
	else
	{
		string code = $2->getCode();
		code += "MOV AX," + $2->getAssemblyID() + "\n";
		code += "MOV " + curfunction + "_return,AX\n";
		code += "JMP LReturn" + curfunction + "\n";
		$$->setCode(code);
	}
	$$->setName("return " + $2->getName() + ";");
};

expression_statement : SEMICOLON
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : expression_statement->SEMICOLON\n\n", line_count);
	fprintf(parsertext, ";\n\n");
	$$->setName(";");
}
| expression SEMICOLON
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : expression_statement->expression SEMICOLON\n\n", line_count);
	fprintf(parsertext, "%s;\n\n", $1->getName().c_str());
	$$->setName($1->getName() + ";");
	$$->setCode($1->getCode());
	$$->setAssemblyID($1->getAssemblyID());
};

variable : ID
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : variable->ID\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	if (table->lookup($1->getName()) == 0)
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Undeclared Variable: %s \n\n", line_count, $1->getName().c_str());
	}
	else if (table->lookup($1->getName())->getReturnType() == "int array" || table->lookup($1->getName())->getReturnType() == "float array")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Not an array: %s \n\n", line_count, $1->getName().c_str());
	}
	if (table->lookup($1->getName()) != 0)
	{
		//cout<<line_count<<" "<<$1->getName()<<" "<<table->lookup($1->getName())->getReturnType()<<endl;
		$$->setReturnType(table->lookup($1->getName())->getReturnType());
		$$->setAssemblyID($1->getName() + IntTotable->lookupscopeid($1->getName())));
	}
	$$->setName($1->getName());
	$$->set_type("notarray");
}
| ID LTHIRD expression RTHIRD
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : variable->ID LTHIRD expression RTHIRD\n\n", line_count);
	fprintf(parsertext, "%s[%s]\n\n", $1->getName().c_str(), $3->getName().c_str());
	if (table->lookup($1->getName()) == 0)
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Undeclared Variable: %s \n\n", line_count, $1->getName().c_str());
	}
	//cout<<line_count<<" "<<$3->getReturnType()<<endl;
	else if ($3->getReturnType() == "float " || $3->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Non-integer Array Index  \n\n", line_count);
		$$->setAssemblyID($1->getName() + IntTotable->lookupscopeid($1->getName())));
	}
	else if (table->lookup($1->getName()) != 0)
	{
		//cout<<line_count<<" "<<table->lookup($1->getName())->getReturnType()<<endl;
		if (table->lookup($1->getName())->getReturnType() != "int array" && table->lookup($1->getName())->getReturnType() != "float array")
		{

			error_count++;
			fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		}
		else
		{

			if (table->lookup($1->getName())->getReturnType() == "int array")
			{

				$1->setReturnType("int ");
			}
			if (table->lookup($1->getName())->getReturnType() == "float array")
			{
				$1->setReturnType("float ");
			}
			$$->setReturnType($1->getReturnType());
			string code = "";
			code += $3->getCode();
			code += "MOV BX," + $3->getAssemblyID() + "\n";
			code += "ADD BX,BX\n";
			$$->setAssemblyID($1->getName() + IntTotable->lookupscopeid($1->getName())));
			//cout<<line_count<<" "<<$$->getAssemblyID()<<endl;
			$$->setCode(code);
		}
	}
	$$->setName($1->getName() + "[" + $3->getName() + "]");
	$$->set_type("array");
};
expression : logic_expression
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : expression->logic_expression\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName());
	$$->setReturnType($1->getReturnType());
	$$->setCode($1->getCode());
	$$->setAssemblyID($1->getAssemblyID());
}
| variable ASSIGNOP logic_expression
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : expression->variable ASSIGNOP logic_expression\n\n", line_count);
	fprintf(parsertext, "%s=%s\n\n", $1->getName().c_str(), $3->getName().c_str());
	if ($3->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		$$->setReturnType("int ");
	}
	else
	{
		//cout<<line_count<<" "<<table->lookup($1->getName())->getReturnType()<<""<<$3->getReturnType()<<endl;
		if ($1->getReturnType() != $3->getReturnType())
		{
			error_count++;
			fprintf(error, "Error at Line No.%d: Type Mismatch \n\n", line_count);
		}
		else
		{
			string code = $1->getCode();
			code += $3->getCode();
			code += "MOV AX," + $3->getAssemblyID() + "\n";
			if ($1->get_type() == "notarray")
			{

				code += "MOV " + $1->getAssemblyID() + ",AX\n";
			}
			else
			{

				code += "MOV " + $1->getAssemblyID() + "[BX],AX\n";
			}
			$$->setCode(code);

			$$->setAssemblyID($1->getAssemblyID());
		}
	}
	$$->setReturnType($1->getReturnType());
	$$->setName($1->getName() + "=" + $3->getName());
};
logic_expression : rel_expression
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : logic_expression->rel_expression\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName());
	$$->setReturnType($1->getReturnType());
	$$->setCode($1->getCode());
	$$->setAssemblyID($1->getAssemblyID());
}
| rel_expression LOGICOP rel_expression
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : logic_expression->rel_expression LOGICOP rel_expression\n\n", line_count);
	fprintf(parsertext, "%s%s%s\n\n", $1->getName().c_str(), $2->getName().c_str(), $3->getName().c_str());
	if ($1->getReturnType() == "void " || $3->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		$$->setReturnType("int ");
	}
	else
	{
		string code = $1->getCode();
		code += $3->getCode();
		string label1 = newLabel();
		string label2 = newLabel();
		string label3 = newLabel();
		string temp = generateNewTempVariable();

		if ($2->getName() == "||")
		{
			code += "MOV AX," + $1->getAssemblyID() + "\n";
			code += "CMP AX,0\n";
			code += "JNE " + label2 + "\n";
			code += "MOV AX," + $3->getAssemblyID() + "\n";
			code += "CMP AX,0\n";
			code += "JNE " + label2 + "\n";
			code += label1 + ":\n";
			code += "MOV " + temp) + ",0\n";
			code += "JMP " + label3 + "\n";
			code += label2 + ":\n";
			code += "MOV " + temp) + ",1\n";
			code += label3 + ":\n";
		}
		else
		{
			code += "MOV AX," + $1->getAssemblyID() + "\n";
			code += "CMP AX,0\n";
			code += "JE " + label2 + "\n";
			code += "MOV AX," + $3->getAssemblyID() + "\n";
			code += "CMP AX,0\n";
			code += "JE " + label2 + "\n";
			code += label1 + ":\n";
			code += "MOV " + temp) + ",1\n";
			code += "JMP " + label3 + "\n";
			code += label2 + ":\n";
			code += "MOV " + temp) + ",0\n";
			code += label3 + ":\n";
		}
		$$->setCode(code);
		$$->setAssemblyID(temp);
		var_dec.push_back(temp);
	}
	$$->setReturnType("int ");
	$$->setName($1->getName() + $2->getName() + $3->getName());
};

rel_expression : simple_expression
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : rel_expression->simple_expression\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName());
	$$->setReturnType($1->getReturnType());
	$$->setCode($1->getCode());
	$$->setAssemblyID($1->getAssemblyID());
}
| simple_expression RELOP simple_expression
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : rel_expression->simple_expression RELOP simple_expression\n\n", line_count);
	fprintf(parsertext, "%s%s%s\n\n", $1->getName().c_str(), $2->getName().c_str(), $3->getName().c_str());
	if ($1->getReturnType() == "void " || $3->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		$$->setReturnType("int ");
	}
	else
	{
		string code = $1->getCode();
		code += $3->getCode();
		string temp = generateNewTempVariable();
		string label1 = newLabel();
		string label2 = newLabel();
		code += "MOV AX," + $1->getAssemblyID() + "\n";
		code += "CMP AX," + $3->getAssemblyID() + "\n";
		if ($2->getName() == "<")
		{
			code += "JL " + label1 + "\n";
		}
		else if ($2->getName() == ">")
		{
			code += "JG " + label1 + "\n";
		}
		else if ($2->getName() == "<=")
		{
			code += "JLE " + label1 + "\n";
		}
		else if ($2->getName() == ">=")
		{
			code += "JGE " + label1 + "\n";
		}
		else if ($2->getName() == "==")
		{
			code += "JE " + label1 + "\n";
		}
		else if ($2->getName() == "!=")
		{
			code += "JNE " + label1 + "\n";
		}
		code += "MOV " + temp) + ",0\n";
		code += "JMP " + label2 + "\n";
		code += label1 + ":\n";
		code += "MOV " + temp) + ",1\n";
		code += label2 + ":\n";
		var_dec.push_back(temp);
		$$->setCode(code);
		$$->setAssemblyID(temp);
	}
	$$->setReturnType("int ");

	$$->setName($1->getName() + $2->getName() + $3->getName());
};

simple_expression : term
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : simple_expression->term\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setReturnType($1->getReturnType());
	$$->setName($1->getName());
	$$->setCode($1->getCode());
	$$->setAssemblyID($1->getAssemblyID());
}
| simple_expression ADDOP term
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : simple_expression->simple_expression ADDOP term\n\n", line_count);
	fprintf(parsertext, "%s%s%s\n\n", $1->getName().c_str(), $2->getName().c_str(), $3->getName().c_str());
	//cout<<$3->getReturnType()<<endl;
	if ($1->getReturnType() == "void " || $3->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		$$->setReturnType("int ");
	}
	else
	{
		if ($1->getReturnType() == "float " || $3->getReturnType() == "float ")
			$$->setReturnType("float ");
		else
			$$->setReturnType("int ");
		string code = $1->getCode() + $3->getCode();

		code += "MOV AX," + $1->getAssemblyID() + "\n";
		string temp = generateNewTempVariable();
		if ($2->getName() == "+")
		{
			code += "ADD AX," + $3->getAssemblyID() + "\n";
		}
		else
		{
			code += "SUB AX," + $3->getAssemblyID() + "\n";
		}
		code += "MOV " + temp) + ",AX\n";
		$$->setCode(code);
		$$->setAssemblyID(temp);
		var_dec.push_back(temp);
	}
	$$->setName($1->getName() + $2->getName() + $3->getName());
};

term : unary_expression
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : term->unary_expression\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());

	$$->setReturnType($1->getReturnType());

	$$->setName($1->getName());
	$$->setCode($1->getCode());
	$$->setAssemblyID($1->getAssemblyID());
}
| term MULOP unary_expression
{

	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : term->term MULOP unary_expression\n\n", line_count);
	fprintf(parsertext, "%s%s%s\n\n", $1->getName().c_str(), $2->getName().c_str(), $3->getName().c_str());
	if ($1->getReturnType() == "void " || $3->getReturnType() == "void ")
	{

		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		$$->setReturnType("int ");
	}
	else if ($2->getName() == "%")
	{
		if ($1->getReturnType() != "int " || $3->getReturnType() != "int ")
		{
			error_count++;
			fprintf(error, "Error at Line No.%d:  Integer operand on modulus operator  \n\n", line_count);
		}
		else
		{
			$$->setReturnType("int ");
		}
		string code = $1->getCode() + $3->getCode();
		string temp = generateNewTempVariable();
		code += "MOV AX," + $1->getAssemblyID() + "\n";
		code += "MOV BX," + $3->getAssemblyID() + "\n";
		code += "MOV DX,0\n";
		code += "DIV BX\n";
		code += "MOV " + temp) + ", DX\n";
		$$->setCode(code);
		$$->setAssemblyID(temp);
		var_dec.push_back(temp);
	}
	else if ($2->getName() == "/")
	{
		if ($1->getReturnType() == "void " || $3->getReturnType() == "void ")
		{
			error_count++;
			fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
			$$->setReturnType("int ");
		}
		else
		{
			if ($1->getReturnType() == "int " && $3->getReturnType() == "int ")
				$$->setReturnType("int ");
			else
				$$->setReturnType("float ");
			string code = $1->getCode() + $3->getCode();
			string temp = generateNewTempVariable();
			code += "MOV AX," + $1->getAssemblyID() + "\n";
			code += "MOV BX," + $3->getAssemblyID() + "\n";
			code += "DIV BX\n";
			code += "MOV " + temp) + ", AX\n";
			$$->setCode(code);
			$$->setAssemblyID(temp);
			var_dec.push_back(temp);
		}
	}
	else
	{
		if ($1->getReturnType() == "void " || $3->getReturnType() == "void ")
		{
			error_count++;
			fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
			$$->setReturnType("int ");
		}
		else
		{
			if ($1->getReturnType() == "float " || $3->getReturnType() == "float ")
				$$->setReturnType("float ");
			else
				$$->setReturnType("int ");

			string code = $1->getCode() + $3->getCode();
			string temp = generateNewTempVariable();
			code += "MOV AX," + $1->getAssemblyID() + "\n";
			code += "MOV BX," + $3->getAssemblyID() + "\n";
			code += "MUL BX\n";
			code += "MOV " + temp) + ", AX\n";
			$$->setCode(code);
			$$->setAssemblyID(temp);
			var_dec.push_back(temp);
		}
	}
	$$->setName($1->getName() + $2->getName() + $3->getName());
};

unary_expression : ADDOP unary_expression
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : unary_expression->ADDOP unary_expression\n\n", line_count);
	fprintf(parsertext, "%s%s\n\n", $1->getName().c_str(), $2->getName().c_str());
	if ($2->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		$$->setReturnType("int ");
	}
	else
	{
		string code = $2->getCode();
		if ($1->getName() == "-")
		{
			code += "MOV AX," + $2->getAssemblyID() + "\n";
			code += "NEG AX\n";
			code += "MOV " + $2->getAssemblyID() + ",AX\n";
		}
		$$->setCode(code);
		$$->setAssemblyID($2->getAssemblyID());

		$$->setReturnType($2->getReturnType());
	}
	$$->setName($1->getName() + $2->getName());
}
| NOT unary_expression
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : unary_expression->NOT unary_expression\n\n", line_count);
	fprintf(parsertext, "!%s\n\n", $2->getName().c_str());
	if ($2->getReturnType() == "void ")
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Type Mismatch \n\n", line_count);
		$$->setReturnType("int ");
	}
	else
	{
		$$->setReturnType($2->getReturnType());
		string code = $2->getCode();
		code += "MOV AX," + $2->getAssemblyID() + "\n";
		code += "NOT AX\n";
		code += "MOV " + $2->getAssemblyID() + ",AX\n";

		$$->setCode(code);
		$$->setAssemblyID($2->getAssemblyID());
	}

	$$->setName("!" + $2->getName());
}
| factor
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : unary_expression->factor\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	// cout<<$1->getReturnType()<<endl;
	$$->setReturnType($1->getReturnType());
	$$->setName($1->getName());
	$$->setCode($1->getCode());
	$$->setAssemblyID($1->getAssemblyID());
};

factor : variable
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : factor->variable\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setReturnType($1->getReturnType());
	$$->setName($1->getName());

	string code = $1->getCode();
	if ($1->get_type() == "array")
	{
		string temp = generateNewTempVariable();
		code += "MOV AX," + $1->getAssemblyID() + "[BX]\n";
		code += "MOV " + temp) + ",AX\n";
		var_dec.push_back(temp);
		$$->setAssemblyID(temp);
	}
	else
	{
		$$->setAssemblyID($1->getAssemblyID());
	}

	$$->setCode(code);
}
| ID LPAREN argument_list RPAREN
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : factor->ID LPAREN argument_list RPAREN\n\n", line_count);
	fprintf(parsertext, "%s(%s)\n\n", $1->getName().c_str(), $3->getName().c_str());
	SymbolInfo *s = table->lookup($1->getName());
	if (s == 0)
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Undefined Function \n\n", line_count);
		$$->setReturnType("int ");
	}
	else if (s->get_isFunction() == 0)
	{
		error_count++;
		fprintf(error, "Error at Line No.%d:  Not A Function \n\n", line_count);
		$$->setReturnType("int ");
	}
	else
	{
		if (s->get_isFunction()->get_isdefined() == 0)
		{
			error_count++;
			fprintf(error, "Error at Line No.%d:  Undeclared Function \n\n", line_count);
		}

		int num = s->get_isFunction()->get_number_of_parameter();
		//cout<<line_count<<" "<<arg_list.size()<<endl;
		$$->setReturnType(s->get_isFunction()->get_return_type());
		if (num != arg_list.size())
		{
			error_count++;
			fprintf(error, "Error at Line No.%d:  Invalid number of arguments %s\n\n", line_count, $1->getName().c_str());
		}
		else
		{
			string code = $3->getCode();
			//cout<<s->get_isFunction()->get_return_type()<<endl;

			vector<string> para_list = s->get_isFunction()->get_paralist();
			vector<string> para_type = s->get_isFunction()->get_paratype();
			vector<string> var_list = s->get_isFunction()->get_var();

			for (int i = 0; i < arg_list.size(); i++)
			{
				code += "MOV AX," + arg_list[i]->getAssemblyID() + "\n";
				code += "MOV " + para_list[i] + ",AX\n";
				//cout<<para_list[i]<<" "<<arg_list[i]->getName()<<" "<<arg_list[i]->getAssemblyID()<<endl;
				if (arg_list[i]->getReturnType() != para_type[i])
				{

					error_count++;
					fprintf(error, "Error at Line No.%d: Type Mismatch \n\n", line_count);
					break;
				}
			}

			code += "CALL " + $1->getName() + "\n";

			code += "MOV AX," + $1->getName() + "_return\n";
			string temp = generateNewTempVariable();
			code += "MOV " + temp) + ",AX\n";
			$$->setCode(code);
			$$->setAssemblyID(temp);
			var_dec.push_back(temp);
		}
	}
	arg_list.clear();
	//cout<<line_count<<" "<<$$->getReturnType()<<endl;
	$$->setName($1->getName() + "(" + $3->getName() + ")");
}
| LPAREN expression RPAREN
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : factor->LPAREN expression RPAREN\n\n", line_count);
	fprintf(parsertext, "(%s)\n\n", $2->getName().c_str());
	$$->setReturnType($2->getReturnType());
	$$->setName("(" + $2->getName() + ")");
	$$->setCode($2->getCode());
	$$->setAssemblyID($2->getAssemblyID());
}
| CONST_INT
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : factor->CONST_INT\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setReturnType("int ");
	$$->setName($1->getName());
	string temp = generateNewTempVariable();
	string code = "MOV " + temp) + "," + $1->getName() + "\n";
	$$->setCode(code);
	$$->setAssemblyID(temp));
	//cout<<code<<endl;
	var_dec.push_back(temp);
}
| CONST_FLOAT
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : factor->CONST_FLOAT\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setReturnType("float ");
	$$->setName($1->getName());
	string temp = generateNewTempVariable();
	string code = "MOV " + temp) + "," + $1->getName() + "\n";
	$$->setCode(code);
	$$->setAssemblyID(temp));
	var_dec.push_back(temp);
}
| variable INCOP
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : factor->variable INCOP\n\n", line_count);
	fprintf(parsertext, "%s++\n\n", $1->getName().c_str());
	$$->setReturnType($1->getReturnType());
	string temp = generateNewTempVariable();
	string code = "";
	//todo find if this actually works.
	if ($1->get_type() == "array")
	{
		code += "MOV AX," + $1->getAssemblyID() + "[BX]\n";
	}
	else
		code += "MOV AX," + $1->getAssemblyID() + "\n";

	code += "MOV " + temp) + ",AX\n";
	if ($1->get_type() == "array")
	{
		code += "MOV AX," + $1->getAssemblyID() + "[BX]\n";
		code += "INC AX\n";
		code += "MOV " + $1->getAssemblyID() + "[BX],AX\n";
	}
	else
		code += "INC " + $1->getAssemblyID() + "\n";
	var_dec.push_back(temp);

	$$->setName($1->getName() + "++");
	$$->setCode(code);
	$$->setAssemblyID(temp);
}
| variable DECOP
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : factor->variable DECOP\n\n", line_count);
	fprintf(parsertext, "%s--\n\n", $1->getName().c_str());
	$$->setReturnType($1->getReturnType());
	string temp = generateNewTempVariable();
	string code = "";
	if ($1->get_type() == "array")
	{
		code += "MOV AX," + $1->getAssemblyID() + "[BX]\n";
	}
	else
		code += "MOV AX," + $1->getAssemblyID() + "\n";
	code += "MOV " + temp) + ",AX\n";
	if ($1->get_type() == "array")
	{
		code += "MOV AX," + $1->getAssemblyID() + "[BX]\n";
		code += "DEC AX\n";
		code += "MOV " + $1->getAssemblyID() + "[BX],AX\n";
	}
	else
		code += "DEC " + $1->getAssemblyID() + "\n";
	var_dec.push_back(temp);
	$$->setName($1->getName() + "--");
	$$->setCode(code);
	$$->setAssemblyID(temp);
};

argument_list : arguments
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : argument_list->arguments\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	$$->setName($1->getName());
	$$->setCode($1->getCode());
}
| % empty
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : argument_list-> \n\n", line_count);
	$$->setName("");
};

arguments : arguments COMMA logic_expression
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : arguments->arguments COMMA logic_expression \n\n", line_count);
	fprintf(parsertext, "%s,%s\n\n", $1->getName().c_str(), $3->getName().c_str());
	arg_list.push_back($3);
	$$->setName($1->getName() + "," + $3->getName());
	$$->setCode($1->getCode() + $3->getCode());
}
| logic_expression
{
	$$ = new SymbolInfo();
	fprintf(parsertext, "Line at %d : arguments->logic_expression\n\n", line_count);
	fprintf(parsertext, "%s\n\n", $1->getName().c_str());
	arg_list.push_back($1);
	// cout<<$1->getReturnType()<<endl;
	$$->setName($1->getName());
	$$->setCode($1->getCode());
};
% %
	bool check(string s1, string s2)
{

	if (s1.size() != s2.size() || s1.size() < 11)
		return false;
	int j = 0;
	for (; j < s1.size(); j++)
	{
		if (s1[j] == 'M')
			break;
	}
	if (j == s1.size())
		return false;

	if (s1[j] != 'M' || s1[j + 1] != 'O' || s1[j + 2] != 'V')
		return false;
	j = 0;
	for (; j < s2.size(); j++)
	{
		if (s2[j] == 'M')
			break;
	}
	if (j == s2.size())
		return false;

	if (s2[j] != 'M' || s2[j + 1] != 'O' || s2[j + 2] != 'V')
		return false;

	//	cout<<s1<<endl;
	//	cout<<s2<<endl;

	string source1 = "", dist1 = "";
	string source2 = "", dist2 = "";
	int i;
	for (i = j + 4; i < s1.size() - 1; i++)
	{
		if (s1[i] == ' ' and source1.size() == 0)
			continue;
		if (s1[i] == ' ' || s1[i] == ',')
			break;
		source1.push_back(s1[i]);
	}
	//cout<<source1<<" ";
	for (; i < s1.size() - 1; i++)
	{
		if ((s1[i] == ' ' || s1[i] == ',') and dist1.size() == 0)
			continue;
		if (s1[i] == ' ')
			break;
		dist1.push_back(s1[i]);
	}
	//cout<<dist1<<" ";

	for (i = j + 4; i < s2.size() - 1; i++)
	{
		if (s2[i] == ' ' and source2.size() == 0)
			continue;
		if (s2[i] == ' ' || s2[i] == ',')
			break;
		source2.push_back(s2[i]);
	}
	//cout<<source2<<" ";
	for (; i < s2.size() - 1; i++)
	{
		if ((s2[i] == ' ' || s2[i] == ',') and dist2.size() == 0)
			continue;
		if (s2[i] == ' ')
			break;
		dist2.push_back(s2[i]);
	}
	//cout<<dist2<<endl;

	//cout<<source1<<","<<dist1<<endl<<source2<<","<<dist2<<endl;
	if (dist1 == source2 and dist2 == source1)
		return true;

	return false;
}
void optimization(FILE *asmcode)
{
	FILE *optcode = fopen("optcode.asm", "w");
	string line = NULL;
	size_t len = 0;
	ssize_t read;
	vector<string> v;
	while ((read = getline(&line, &len, asmcode)) != -1)
	{
		// printf("%s", line);
		v.push_back(line));
	}
	int sz = v.size();
	int mark[sz];
	for (int i = 0; i < sz; i++)
		mark[i] = 1;
	for (int i = 0; i < sz - 1; i++)
	{
		if (check(v[i], v[i + 1]))
		{
			mark[i + 1] = 0;
		}
	}
	for (int i = 0; i < sz; i++)
	{
		if (mark[i])
			fprintf(optcode, "%s", v[i].c_str());
	}

	fclose(asmcode);
	fclose(optcode);
	if (line)
		free(line);
}
int main(int argc, string argv[])
{

	if ((fp = fopen(argv[1], "r")) == NULL)
	{
		printf("Cannot Open Input File.\n");
		return 0;
	}
	yyin = fp;
	table->Enter_Scope();
	yyparse();
	fprintf(parsertext, " Symbol Table : \n\n");
	table->printall();
	fprintf(parsertext, "Total Lines : %d \n\n", line_count);
	fprintf(parsertext, "Total Errors : %d \n\n", error_count);
	fprintf(error, "Total Errors : %d \n\n", error_count);

	fclose(fp);
	fclose(parsertext);
	fclose(error);

	return 0;
}
